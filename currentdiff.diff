diff --git a/src/commands/ai.rs b/src/commands/ai.rs
index a3da7b9..53cff6e 100644
--- a/src/commands/ai.rs
+++ b/src/commands/ai.rs
@@ -1,7 +1,3 @@
-use serenity::builder::CreateApplicationCommand;
-use serenity::model::application::command::CommandOptionType;
-use serenity::model::application::interaction::application_command::{CommandDataOption, CommandDataOptionValue};
-
 extern crate dotenv;
 extern crate serde_json;
 use dotenv::dotenv;
@@ -10,12 +6,7 @@ use serde_json::json;
 use std::time::Duration;
 use std::env;
 use reqwest;
-use crate::common::constants::MAX_MSG_SZ;
-
-#[allow(deprecated)]
-use serenity::model::interactions::application_command::ApplicationCommandInteraction;
-use serenity::model::application::interaction::InteractionResponseType;
-use serenity::prelude::*;
+use crate::{Context, Error};
 
 
 static TIMEOUT : u64 = 30;
@@ -39,21 +30,17 @@ pub fn format_string(output: String) -> String
     output
 }
 
-//connect to the local LLM model running on desktop
-pub async fn run(options: &[CommandDataOption]) -> String 
+//connect to the model by http
+#[poise::command(slash_command)]
+pub async fn send_prompt(
+    ctx: Context<'_>,
+    #[description = "The prompt to pass to the LLM"] prompt: String
+    ) -> Result<(), Error>
 {
     dotenv().ok();
     let model : String = env::var("LLM_MODEL").unwrap();
     let server_ip : String = env::var("SERVER_IP").unwrap();
     let server_port: String = env::var("SERVER_PORT").unwrap();
-    let option = options
-        .get(0)
-        .expect("Expected prompt option")
-        .resolved
-        .as_ref()
-        .expect("Expected prompt option");
-    if let CommandDataOptionValue::String(query) = option 
-    {
     let url: String = format!("http://{}:{}/v1/chat/completions", server_ip, server_port);
     let json = &json!(
     {
@@ -61,7 +48,7 @@ pub async fn run(options: &[CommandDataOption]) -> String
         "messages":
             [
                 {"role" : "system", "content": SYSTEM_PROMPT},
-                        {"role" : "user", "content": query},
+                {"role" : "user", "content": prompt},
             ],
         "temperature" : 1,
         "max_tokens": 1024,
@@ -80,7 +67,8 @@ pub async fn run(options: &[CommandDataOption]) -> String
         .and_then(|v| { success = true; Ok(v) });
     if !success
     {
-                return String::from("Unable to connect to LLM server, Connor's desktop probably isn't running");
+        ctx.say("Unable to connect to LLM server, Connor's desktop probably isn't running").await;
+        return Ok(())
     }
     let res = res.unwrap();
     match res.status()
@@ -99,65 +87,48 @@ pub async fn run(options: &[CommandDataOption]) -> String
                 .unwrap()
                 .to_string();
             println!("{:?}", json_result);
-                    format_string(output)
+            ctx.say(format_string(output));
+            Ok(())
         },
         reqwest::StatusCode::UNAUTHORIZED =>
         {
-                    String::from("Error authorizing request")
+            ctx.say("Error authorizing request");
+            Ok(())
         }
         _ =>
         {
-                    println!("error: got result {} from api", res.status().to_string());
-                    panic!("Unexpected error in API response");
+            ctx.say(format!("error: got result {} from api", res.status().to_string()));
+            Ok(())
         }
     }
 }
-    else 
-    {
-        "Please provide a valid query.".to_string()
-    }
-}
-
-pub fn register(command: &mut CreateApplicationCommand) -> &mut CreateApplicationCommand 
-{
-    command.name("ai").description("Submit a prompt to Google's LLM")
-    .create_option(|option| {
-        option
-            .name("prompt")
-            .description("The prompt you want to pass to the AI model")
-            .kind(CommandOptionType::String)
-            .required(true)
-        });
-    command
-}
 
-#[allow(deprecated)]
-pub async fn interaction(ctx: Context, command: &ApplicationCommandInteraction) 
-{
-    command.create_interaction_response(&ctx.http, |response| 
-    {
-        response
-            .kind(InteractionResponseType::DeferredChannelMessageWithSource)
-            .interaction_response_data(|message| message.content(command.data.name.as_str()))
-    }).await.unwrap();
-    let res = run(&command.data.options).await;
-    if res.chars().count() >= MAX_MSG_SZ 
-    {
-        let char_vec: Vec<char> = res.chars().collect();
-        let first_message_str: String = char_vec[..MAX_MSG_SZ].into_iter().collect();
-        let second_message_str: String = char_vec[MAX_MSG_SZ..].into_iter().collect();
-        command.edit_original_interaction_response(&ctx.http, |response| {
-            response.content(&first_message_str)
-        }).await.unwrap();
-        command.create_followup_message(&ctx.http, |response| {
-            response.content(&second_message_str)
-        }).await.unwrap();
-    }
-    else 
-    {
-        command.edit_original_interaction_response(&ctx.http, |response| 
-        {
-            response.content(&res)
-        }).await.unwrap();
-    }
-}
+//pub async fn interaction(ctx: Context<'_>, command: &ApplicationCommandInteraction)
+//{
+//    command.create_interaction_response(&ctx.http, |response|
+//    {
+//        response
+//            .kind(InteractionResponseType::DeferredChannelMessageWithSource)
+//            .interaction_response_data(|message| message.content(command.data.name.as_str()))
+//    }).await.unwrap();
+//    let res = run(&command.data.options).await;
+//    if res.chars().count() >= MAX_MSG_SZ
+//    {
+//        let char_vec: Vec<char> = res.chars().collect();
+//        let first_message_str: String = char_vec[..MAX_MSG_SZ].into_iter().collect();
+//        let second_message_str: String = char_vec[MAX_MSG_SZ..].into_iter().collect();
+//        command.edit_original_interaction_response(&ctx.http, |response| {
+//            response.content(&first_message_str)
+//        }).await.unwrap();
+//        command.create_followup_message(&ctx.http, |response| {
+//            response.content(&second_message_str)
+//        }).await.unwrap();
+//    }
+//    else
+//    {
+//        command.edit_original_interaction_response(&ctx.http, |response|
+//        {
+//            response.content(&res)
+//        }).await.unwrap();
+//    }
+//}
diff --git a/src/commands/freaky.rs b/src/commands/freaky.rs
index 5e0adf0..057ae32 100644
--- a/src/commands/freaky.rs
+++ b/src/commands/freaky.rs
@@ -1,6 +1,4 @@
-use serenity::builder::CreateApplicationCommand;
-use serenity::model::application::command::CommandOptionType;
-use serenity::model::application::interaction::application_command::{CommandDataOption, CommandDataOptionValue};
+use crate::{Context, Error};
 
 pub fn freaktionary(c: char) -> char
 {
@@ -62,37 +60,30 @@ pub fn freaktionary(c: char) -> char
         _ => c
     }
 }
-pub fn run(options: &[CommandDataOption]) -> String
-{
-    let option = options
-        .get(0)
-        .expect("Expected string to freakify")
-        .resolved
-        .as_ref()
-        .expect("Expected string to freakify");
-    if let CommandDataOptionValue::String(text) = option 
+
+#[poise::command(slash_command)]
+pub async fn run(
+    ctx: Context<'_>,
+    #[description = "get 𝓯𝓻𝓮𝓪𝓴𝔂 𝓿𝓻𝓸 ❤️"] text: String
+    ) -> Result<(), Error>
 {
     let mut output = String::new();
     for c in text.chars()
     {
         output.push(freaktionary(c));
     }
-        format!("{output}") 
-    }
-    else
-    {
-        return String::from("𝔂𝓸𝓾 𝓱𝓪𝓿𝓮 𝓽𝓸 𝓰𝓲𝓿𝓮 𝓶𝓮 𝓼𝓸𝓶𝓮 𝓽𝓮𝔁𝓽 𝓿𝓻𝓸 ❤️");
-    }
+    ctx.say(format!("{output}"));
+    Ok(())
 }
 
-pub fn register(command: &mut CreateApplicationCommand) -> &mut CreateApplicationCommand {
-    command.name("freaky").description("get 𝓯𝓻𝓮𝓪𝓴𝔂 𝓿𝓻𝓸 ❤️")
-    .create_option(|option| {
-        option
-            .name("text")
-            .description("the text to freakify")
-            .kind(CommandOptionType::String)
-            .required(true)
-        });
-    return command;
-}
+//pub fn register(command: &mut CreateApplicationCommand) -> &mut CreateApplicationCommand {
+//    command.name("freaky").description("get 𝓯𝓻𝓮𝓪𝓴𝔂 𝓿𝓻𝓸 ❤️")
+//    .create_option(|option| {
+//        option
+//            .name("text")
+//            .description("the text to freakify")
+//            .kind(CommandOptionType::String)
+//            .required(true)
+//        });
+//    return command;
+//}
diff --git a/src/commands/gif.rs b/src/commands/gif.rs
index 674249c..a9675ba 100644
--- a/src/commands/gif.rs
+++ b/src/commands/gif.rs
@@ -1,23 +1,19 @@
-use serenity::builder::CreateApplicationCommand;
-use serenity::model::application::command::CommandOptionType;
-use serenity::model::application::interaction::application_command::{CommandDataOption, CommandDataOptionValue};
-
 extern crate dotenv;
 extern crate serde_json;
 use dotenv::dotenv;
 use serde_json::Value;
 use std::env;
 use reqwest;
+use crate::{Context, Error};
 
-pub async fn run(options: &[CommandDataOption]) -> String {
+#[poise::command(slash_command)]
+pub async fn run
+(
+    ctx: Context<'_>,
+    #[description = "The query to be passed to Tenor's API"] query: String
+) -> Result<(), Error>
+{
     dotenv().ok();
-    let option = options
-        .get(0)
-        .expect("Expected query option")
-        .resolved
-        .as_ref()
-        .expect("Expected query option");
-    if let CommandDataOptionValue::String(query) = option {
     let query_string: String = format!("https://g.tenor.com/v1/search?q={}&key={}&limit=1", query, env::var("TENOR_KEY").expect("Expected a Tenor key"));
     let result_code = reqwest::get(query_string.clone())
         .await
@@ -38,31 +34,15 @@ pub async fn run(options: &[CommandDataOption]) -> String {
                 .unwrap()
                 .to_string();
             let url = &url[1..url.len()-1];
-                    format!("\n{}", url)
+            ctx.say(format!("\n{}", url));
+            Ok(())
         },
         reqwest::StatusCode::UNAUTHORIZED => {
-                    String::from("Error authorizing request")
+            ctx.say("Error authorizing request");
+            Err(Error::from("Error authorizing request"))
         }
         _ => {
             panic!("Unexpected error in Tenor response");
         }
     }
 }
-    else {
-        "Please provide a valid query.".to_string()
-    }
-}
-
-
-
-pub fn register(command: &mut CreateApplicationCommand) -> &mut CreateApplicationCommand {
-    command.name("gif").description("Query Tenor for a gif")
-    .create_option(|option| {
-        option
-            .name("word")
-            .description("The query to be passed to Tenor's API")
-            .kind(CommandOptionType::String)
-            .required(true)
-        });
-    command
-} 
\ No newline at end of file
diff --git a/src/commands/help.rs b/src/commands/help.rs
index 183981e..71b46db 100644
--- a/src/commands/help.rs
+++ b/src/commands/help.rs
@@ -1,9 +1,8 @@
-use serenity::builder::CreateApplicationCommand;
-pub fn run() -> String {
-    String::from("https://github.com/connorcinna/RustyBlitzcrank#readme")
-}
+use crate::{Context, Error};
 
-pub fn register(command: &mut CreateApplicationCommand) -> &mut CreateApplicationCommand {
-    command.name("help").description("Information about Blitzcrank and it's commands");
-    command
+#[poise::command(slash_command)]
+pub async fn run(ctx: Context<'_>) -> Result<(), Error> 
+{
+    ctx.say("https://github.com/connorcinna/RustyBlitzcrank#readme");
+    Ok(())
 }
diff --git a/src/commands/jerma.rs b/src/commands/jerma.rs
index 4babffa..b4bf360 100644
--- a/src/commands/jerma.rs
+++ b/src/commands/jerma.rs
@@ -1,7 +1,9 @@
-use serenity::builder::CreateApplicationCommand;
+use crate::{Context, Error};
 
-pub fn run() -> String {
-    String::from("⡯⡯⡾⠝⠘⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢊⠘⡮⣣⠪⠢⡑⡌  
+#[poise::command(slash_command)]
+pub async fn run(ctx: Context<'_>) -> Result<(), Error>
+{
+    ctx.say("⡯⡯⡾⠝⠘⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢊⠘⡮⣣⠪⠢⡑⡌  
             ⠟⠝⠈⠀⠀⠀. ⠡⠀⠠⢈⠠⢐⢠⢂⢔⣐⢄⡂⢔⠀⡁⢉⠸⢨⢑⠕⡌ 
             ⠀ ⡀⠁⠀⠀⠀⡀⢂⠡⠈⡔⣕⢮⣳⢯⣿⣻⣟⣯⣯⢷⣫⣆⡂ ⢐⠑⡌
             ⢀⠠⠐⠈⠀⢀⢂⠢⡂⠕⡁⣝⢮⣳⢽⡽⣾⣻⣿⣯⡯⣟⣞⢾⢜⢆⠀⡀⠀⠪
@@ -21,10 +23,6 @@ pub fn run() -> String {
             ⡯⣳⠯⠚⢊⠡⡂⢂⠨⠊⠔⡑⠬⡸⣘⢬⢪⣪⡺⡼⣕⢯⢞⢕⢝⠎⢻⢼⣀⠀
             ⠁⡂⠔⡁⡢⠣⢀⠢⠀⠅⠱⡐⡱⡘⡔⡕⡕⣲⡹⣎⡮⡏⡑⢜⢼⡱⢩⣗⣯⣟
             ⢀⢂⢑⠀⡂⡃⠅⠊⢄⢑⠠⠑⢕⢕⢝⢮⢺⢕⢟⢮⢊⢢⢱⢄⠃⣇⣞⢞⣞⢾
-            ⢀⠢⡑⡀⢂⢊⠠⠁⡂⡐⠀⠅⡈⠪⠪⠪⠣⠫⠑⡁⢔⠕⣜⣜⢦⡰⡎⡯⡾⡽") 
-}
-
-pub fn register(command: &mut CreateApplicationCommand) -> &mut CreateApplicationCommand {
-    command.name("jerma").description("He is coming");
-    command
+            ⢀⠢⡑⡀⢂⢊⠠⠁⡂⡐⠀⠅⡈⠪⠪⠪⠣⠫⠑⡁⢔⠕⣜⣜⢦⡰⡎⡯⡾⡽");
+    Ok(())
 }
diff --git a/src/commands/name.rs b/src/commands/name.rs
index 6438d73..b77390e 100644
--- a/src/commands/name.rs
+++ b/src/commands/name.rs
@@ -1,49 +1,41 @@
-use serenity::model::application::interaction::application_command::{CommandDataOption, CommandDataOptionValue};
-use serenity::model::application::command::CommandOptionType;
 use crate::common::helpers::coinflip;
 
-use serenity::builder::CreateApplicationCommand;
 use rand::Rng;
 use serde_json;
 pub static _SIZE : usize = 16;
+use crate::{Context, Error};
 
-pub fn run(options: &[CommandDataOption]) -> String 
+#[poise::command(slash_command)]
+pub async fn run(
+    ctx: Context<'_>,
+    #[description = "The number of names you wish to generate"] num: Option<u32>) -> Result<(), Error>
 {
     let mut name: String = String::new();
-    match options.get(0)
+    match num
     {
         //if a number was passed in
-        Some(value) => 
-        {
-            let option = value.resolved.as_ref().unwrap();
-            if let &CommandDataOptionValue::Integer(num) = option
+        Some(num) =>
         {
             for _ in 0..num
             {
                 name += &generate_name();
                 name += "\n";
             }
-                return name;
-            }
-            else 
-            {
-                return String::from("Error parsing option value.");
-            }
         }
-        //only one
         None =>
         {
             name = generate_name();
-            return name;
         }
     }
+    ctx.say(name);
+    Ok(())
 }
 
  //format: noun + verb + er + random numbers
 pub fn generate_format_one(json: serde_json::value::Value, noun: String) -> String
 {
     let verb: String = random_word(json.clone(), String::from("verbs").clone());
-    let mut rng = rand::thread_rng();
+    let mut rng = rand::rng();
     let mut ret : String;
     let last_chars =
     {
@@ -65,7 +57,7 @@ pub fn generate_format_one(json: serde_json::value::Value, noun: String) -> Stri
     //append random numbers to the end
     while ret.len() < _SIZE as usize
     {
-        ret.push_str(&rng.gen_range(0..10).to_string());
+        ret.push_str(&rng.random_range(0..10).to_string());
     }
     return String::from(ret);
 }
@@ -74,11 +66,11 @@ pub fn generate_format_one(json: serde_json::value::Value, noun: String) -> Stri
 pub fn generate_format_two(json: serde_json::value::Value, noun: String) -> String
 {
     let adjective: String = random_word(json.clone(), String::from("adjectives").clone());
-    let mut rng = rand::thread_rng();
+    let mut rng = rand::rng();
     let mut ret = format!("{}{}", adjective, noun);
     while ret.len() < _SIZE as usize
     {
-        ret.push_str(&rng.gen_range(0..10).to_string());
+        ret.push_str(&rng.random_range(0..10).to_string());
     }
     return String::from(ret);
 }
@@ -116,13 +108,13 @@ pub fn random_word(json: serde_json::Value, word_type: String) -> String
 {
     let word: String;
     let word_obj = json.get(&word_type);
-    let mut rng = rand::thread_rng();
+    let mut rng = rand::rng();
     match word_obj
     {
         Some(v) =>
         {
             let word_size = v.as_array().expect("unable to parse words from json").len();
-            word = v.get(rng.gen_range(0..word_size)).expect("unable to index through words in json").to_string();
+            word = v.get(rng.random_range(0..word_size)).expect("unable to index through words in json").to_string();
         }
         None =>
         {
@@ -131,16 +123,3 @@ pub fn random_word(json: serde_json::Value, word_type: String) -> String
     }
     String::from(&word[1..word.len()-1])
 }
-
-pub fn register(command: &mut CreateApplicationCommand) -> &mut CreateApplicationCommand {
-    command.name("name").description("Generate a random name 16 characters long")
-    .create_option(|option| {
-        option
-            .name("number")
-            .description("Generate multiple names at once")
-            .kind(CommandOptionType::Integer)
-            .required(false)
-        });
-
-    command
-}
diff --git a/src/commands/password.rs b/src/commands/password.rs
index 63255b9..53b20c5 100644
--- a/src/commands/password.rs
+++ b/src/commands/password.rs
@@ -1,29 +1,22 @@
-use serenity::builder::CreateApplicationCommand;
-use serenity::model::application::interaction::application_command::{CommandDataOption, CommandDataOptionValue};
-use serenity::model::application::command::CommandOptionType;
-use rand::Rng;
-use rand::rngs::ThreadRng;
+use rand::prelude::*;
 use serde_json;
 
-#[allow(deprecated)]
-use serenity::model::interactions::application_command::ApplicationCommandInteraction;
-use serenity::prelude::*;
-
+use crate::{Context, Error};
+use poise::serenity_prelude::{CommandInteraction, CreateMessage, CreateInteractionResponse, CreateInteractionResponseMessage};
+use poise::serenity_prelude as serenity;
+use crate::common::helpers::coinflip;
 
 //TODO: refactor this and name.rs to some common file
-pub fn run(options: &[CommandDataOption]) -> String
+//TODO: really need to read the json into string and share it by reference without cloning, would
+//be way more efficient
+#[poise::command(slash_command)]
+pub async fn run(
+    ctx: Context<'_>,
+    #[description = "Number of characters in the password"] size: i64
+) -> Result<(), Error>
 {
-    let mut _size: usize = 0;
-    let ret: String;
     let json: serde_json::Value;
     let s: String;
-    let option = options
-        .get(0)
-        .expect("Expected number of characters")
-        .resolved
-        .as_ref()
-        .expect("Expected number of characters");
-    if let CommandDataOptionValue::Integer(size) = option { _size = *size as usize; }
     let json_file = std::fs::read_to_string("./resources/words.json");
     match json_file
     {
@@ -31,46 +24,38 @@ pub fn run(options: &[CommandDataOption]) -> String
             .expect("unable to convert file to json"),
         Err(e) => panic!("unable to find json file: {}", e),
     }
-
-    let mut noun: String = random_word(json.clone(), String::from("nouns").clone());
-    let rng = rand::thread_rng();
-     //format: noun + verb + er + random numbers
+    let noun: String = randomize_case(&random_word(json.clone(), String::from("nouns").clone()));
     if coinflip()
     {
-        let mut verb: String = random_word(json.clone(), String::from("verbs").clone());
-
-        //randomly capitalize some letters otherwise everything is lowercase
-        noun = randomize_case(&noun);
-        verb = randomize_case(&verb);
-
-        ret = format!("{}{}er", noun, verb);
-        s = finalize(ret.clone(), _size, rng.clone());
+        s = generate_format_one(json, noun, size);
     }
-    //format: adjective + noun + random numbers
     else
     {
-        let mut adjective: String = random_word(json.clone(), String::from("adjectives").clone());
-
-        noun = randomize_case(&noun);
-        adjective = randomize_case(&adjective);
+        s = generate_format_two(json, noun, size);
+    }
 
-        ret = format!("{}{}", adjective, noun);
-        s = finalize(ret.clone(), _size, rng.clone());
+    let builder = CreateMessage::new().content(format!("||{}||", s));
+    let dm = ctx.author().direct_message(&ctx, builder).await;
+    match dm
+    {
+        Ok(_) => println!("Successfully sent dm to {} with new password", ctx.author().name),
+        Err(e) => println!("Error sending dm to {} : {}", ctx.author().name, e)
     }
-    s
+
+    Ok(())
 }
 
 pub fn random_word(json: serde_json::Value, word_type: String) -> String
 {
     let word: String;
-    let mut rng = rand::thread_rng();
+    let mut rng = rand::rng();
     let word_obj = json.get(&word_type);
     match word_obj
     {
         Some(v) =>
         {
             let word_size = v.as_array().expect("unable to parse words from json").len();
-            word = v.get(rng.gen_range(0..word_size)).expect("unable to index through words in json").to_string();
+            word = v.get(rng.random_range(0..word_size)).expect("unable to index through words in json").to_string();
         }
         None =>
         {
@@ -97,7 +82,7 @@ pub fn randomize_case(word: &String)  -> String
     ret
 }
 
-pub fn finalize(mut word: String, _size: usize, mut rng: ThreadRng) -> String
+pub fn finalize(mut word: String, _size: i64, mut rng: ThreadRng) -> String
 {
     let special_chars = ["!", "@", "#", "$", "%", "^", "&", "*", "(", ")", "?", "[", "]"];
     while word.len() < _size as usize
@@ -120,41 +105,52 @@ pub fn finalize(mut word: String, _size: usize, mut rng: ThreadRng) -> String
     s
 }
 
-pub fn coinflip() -> bool
+pub fn generate_format_one(json: serde_json::value::Value, noun: String, size: i64) -> String
+{
+    let verb: String = randomize_case(&random_word(json.clone(), String::from("verbs").clone()));
+    let mut rng = rand::rng();
+    let mut ret : String;
+    let last_chars =
+    {
+        let split_pos = verb.char_indices().nth_back(2).unwrap().0;
+        &verb[..split_pos]
+    };
+    if last_chars == "er"
     {
-    let mut rng = rand::thread_rng();
-    rng.gen::<f32>() >= 0.50
+        ret = format!("{}{}", noun, verb);
     }
-
-pub fn register(command: &mut CreateApplicationCommand) -> &mut CreateApplicationCommand 
+    else if verb.chars().last().unwrap() == 'e'
     {
-    command.name("password").description("Generate a random password between 16-32 characters")
-        .create_option(|option|
+        ret = format!("{}{}r", noun, verb);
+    }
+    else
     {
-                            option
-                                .name("characters")
-                                .description("The number of characters you want your password to be")
-                                .kind(CommandOptionType::Integer)
-                                .required(true)
-                       });
-    command
+        ret = format!("{}{}er", noun, verb);
     }
-
-#[allow(deprecated)]
-pub async fn interaction(ctx: Context, command: &ApplicationCommandInteraction) 
+    //append random numbers to the end
+    while ret.len() < size as usize
     {
-    let res = run(&command.data.options);
-    let dm = command.user.direct_message(&ctx, |message| 
+        ret.push_str(&rng.random_range(0..10).to_string());
+    }
+    return String::from(ret);
+
+}
+
+pub fn generate_format_two(json: serde_json::value::Value, noun: String, size: i64) -> String
 {
-        message.content(format!("||{}||", res))
-    }).await;
-    match dm 
+    let adjective: String = random_word(json.clone(), String::from("adjectives").clone());
+    let mut rng = rand::rng();
+    let mut ret = format!("{}{}", adjective, noun);
+    while ret.len() < size as usize
     {
-        Ok(_) => println!("Successfully sent dm to {} with new password", command.user.name),
-        Err(e) => println!("Error sending DM to {} : {}", command.user.name, e)
+        ret.push_str(&rng.random_range(0..10).to_string());
+    }
+    return String::from(ret);
 }
-    command.create_interaction_response(&ctx.http, |response| 
+
+pub async fn interaction(ctx: serenity::Context, command: CommandInteraction)
 {
-        response.interaction_response_data(|message| message.content("Sent, check your direct messages"))
-    }).await.unwrap();
+    let data = CreateInteractionResponseMessage::new().content("Sent, check your direct messages");
+    let builder = CreateInteractionResponse::Message(data);
+    command.create_response(&ctx.http, builder).await.unwrap();
 }
diff --git a/src/commands/ping_voice.rs b/src/commands/ping_voice.rs
index a4f0303..bf8d579 100644
--- a/src/commands/ping_voice.rs
+++ b/src/commands/ping_voice.rs
@@ -1,77 +1,42 @@
-use serenity::builder::CreateApplicationCommand;
-
-use serenity::model::application::command::CommandOptionType;
-use serenity::model::application::interaction::application_command::{CommandDataOption, CommandDataOptionValue};
-use serenity::model::channel::ChannelType;
 use serenity::model::mention::Mention;
+use poise::serenity_prelude::GuildChannel;
 
-use serenity::client::Context;
+use crate::{Context, Error, Message};
 
 extern crate dotenv;
 extern crate serde_json;
 
-
-pub async fn run(ctx: Context, options: &[CommandDataOption]) -> String {
-    let channel = options
-            .get(0)
-            .expect("Expected channel")
-            .resolved
-            .as_ref()
-            .expect("Expected channel");
-    let mut message: Option<&CommandDataOptionValue> = None;
-    if options.len() > 1 {
-        message = options
-            .get(1)
-            .expect("Expected message")
-            .resolved
-            .as_ref()
-    }
-    
-
-    if let CommandDataOptionValue::Channel(channel) = channel {
+#[poise::command(slash_command)]
+pub async fn run(
+    ctx: Context<'_>,
+    #[description = "The channel to address"] channel: GuildChannel,
+    #[description = "Optional message to attach with the ping"] message: Option<Message>)
+    -> Result<(), Error>
+{
         let id = channel.id;
-        let to_channel = id.to_channel(&ctx.http).await.unwrap();
+        let to_channel = id.to_channel(&ctx.http()).await.unwrap();
         let guild = to_channel.guild().unwrap();
         let mut s: String = String::from("");
-        if let Ok(members) = guild.members(ctx.cache).await {
+        if let Ok(members) = guild.members(ctx.cache())
+        {
             //mention all of the users in the channel
             for member in members {
                 s.push_str(Mention::from(member.user.id).to_string().as_str());
             }
             //check if the user attached a message with the command
-            match message {
-                Some(CommandDataOptionValue::String(message)) => {
-                    s.push_str(message.as_str());
+            match message
+            {
+                Some(m) =>
+                {
+                    s.push_str(&m.content);
                 },
                 None => {},
-                _ => {}
             }
-            return s;
+            ctx.say(s);
         }
-        else {
-            return String::from("No one detected in the voice channel");
+        else
+        {
+            ctx.say("No one detected in the voice channel");
         }
-    }
-    String::from("Unexpected error")
-}
-
-
-pub fn register(command: &mut CreateApplicationCommand) -> &mut CreateApplicationCommand {
-    command.name("ping_voice")
-    .description("@ everyone currently talking in a voice channel")
-    .create_option(|option| {
-        option
-            .name("channel")
-            .description("The voice channel to address")
-            .kind(CommandOptionType::Channel)
-            .channel_types(&[ChannelType::Voice])
-            .required(true)
-    })
-    .create_option(|option| {
-        option
-            .name("message")
-            .description("Message you'd like to include in the channel mention")
-            .kind(CommandOptionType::String)
-    });
-    return command;
+        Ok(())
 }
diff --git a/src/commands/roll.rs b/src/commands/roll.rs
index 85f2552..ac5e66e 100644
--- a/src/commands/roll.rs
+++ b/src/commands/roll.rs
@@ -1,33 +1,14 @@
-use serenity::builder::CreateApplicationCommand;
-use serenity::model::application::command::CommandOptionType;
-use serenity::model::application::interaction::application_command::{CommandDataOption, CommandDataOptionValue};
 use rand::Rng;
+use crate::{Context, Error};
 
-pub fn run(options: &[CommandDataOption]) -> String {
-    let option = options
-        .get(0)
-        .expect("Expected ceiling option")
-        .resolved
-        .as_ref()
-        .expect("Expected ceiling option");
-    if let CommandDataOptionValue::Integer(ceiling) = option {
-        let mut rng = rand::thread_rng();
-        let roll_result: i64 = rng.gen_range(0..*ceiling);
-        format!("{}", roll_result) 
-    }
-    else {
-        "Please provide a valid ceiling value.".to_string()
-    }
-}
-
-pub fn register(command: &mut CreateApplicationCommand) -> &mut CreateApplicationCommand {
-    command.name("roll").description("Roll a dice for a random value between 1 and the value given in the argument, e.g. /roll 50")
-    .create_option(|option| {
-        option
-            .name("ceiling")
-            .description("The maximum value of the dice roll.")
-            .kind(CommandOptionType::Integer)
-            .required(true)
-        });
-    return command;
+#[poise::command(slash_command)]
+pub async fn run(
+    ctx: Context<'_>,
+    #[description = "Ceiling for the random number generation"] ceiling: i64,
+    ) -> Result<(), Error>
+{
+    let mut rng = rand::rng();
+    let roll_result: i64 = rng.random_range(0..ceiling);
+    ctx.say(format!("{}", roll_result));
+    Ok(())
 }
diff --git a/src/commands/search.rs b/src/commands/search.rs
index 3ec7bbf..c48ae22 100644
--- a/src/commands/search.rs
+++ b/src/commands/search.rs
@@ -1,31 +1,27 @@
-use serenity::builder::CreateApplicationCommand;
-use serenity::model::application::command::CommandOptionType;
-use serenity::model::application::interaction::application_command::{CommandDataOption, CommandDataOptionValue};
-#[allow(deprecated)]
-use serenity::model::interactions::application_command::ApplicationCommandInteraction;
-use serenity::model::application::interaction::InteractionResponseType;
-use serenity::prelude::*;
-
-
 extern crate dotenv;
 extern crate serde_json;
+use poise::serenity_prelude as serenity;
+use serenity::builder::{CreateAttachment, CreateMessage};
 use dotenv::dotenv;
 use serde_json::Value;
 use reqwest;
+use tokio::fs::File;
 
+use crate::{Error, Context};
 
-pub type Result<T> = std::result::Result<T, Box<dyn std::error::Error + Send>>;
+//pub type Result<T> = std::result::Result<T, Box<dyn std::error::Error + Send>>;
 
-pub async fn run(options: &[CommandDataOption]) -> Result<String> {
+#[poise::command(slash_command)]
+pub async fn run(
+    ctx: Context<'_>,
+    #[description = "The query to pass to Google's search API"] query: String
+) -> Result<(), Error>
+{
+    ctx.defer();
     dotenv().ok();
-    let option = options
-            .get(0)
-            .expect("Expected query option")
-            .resolved
-            .as_ref()
-            .expect("Expected query option");
-    if let CommandDataOptionValue::String(query) = option {
     let client = reqwest::Client::new();
+    //TODO: reformat this with reqwest params instead of stuffing it all in this url string
+    //also i just realized the key is exposed ?!
     let url = format!("https://www.googleapis.com/customsearch/v1?key=AIzaSyCDvi2YxuEsz5uxR1e1h6gq2iF9Ly_WPZU&cx=71446e05228ee4314&q={}&searchType=image&fileType=jpg&alt=json&num=1", query);
     let response = client
         .get(url)
@@ -40,12 +36,15 @@ pub async fn run(options: &[CommandDataOption]) -> Result<String> {
     match json_result.get("queries")
         .and_then(|value| value.get("nextPage"))
         .and_then(|value| value.get(0))
-            .and_then(|value| value.get("totalResults")) {
-            Some(result_num) => {
-                if result_num == "0" {
+        .and_then(|value| value.get("totalResults"))
+        {
+            Some(result_num) =>
+            {
+                if result_num == "0"
+                {
+                    no_results(ctx);
                     return Err(Box::new(std::fmt::Error));
                 }
-                //else, normal case
             }
             None => {
                 return Err(Box::new(std::fmt::Error));
@@ -56,45 +55,26 @@ pub async fn run(options: &[CommandDataOption]) -> Result<String> {
         .and_then(|value| value.get("link"))
         .unwrap()
         .to_string();
-        Ok(format!("\n{}", &result[1..result.len()-1]))
-    }
-    //dont think this is ever reached?
-    else {
-        return Err(Box::new(std::fmt::Error));
-    }
-}
 
-
-pub fn register(command: &mut CreateApplicationCommand) -> &mut CreateApplicationCommand {
-    command.name("search").description("Search Google images")
-    .create_option(|option| {
-        option
-            .name("word")
-            .description("The query to be passed to Google's search API")
-            .kind(CommandOptionType::String)
-            .required(true)
-        });
-    return command;
+    //right now assuming that ctx.say() will foil the ctx.defer() from earlier
+    ctx.say(format!("\n{}", &result[1..result.len()-1]));
+    Ok(())
 }
 
-//handle deferring the message, wait for the response from API call, and send it to the channel
-//or, if the API didn't find an image link, send the funny blitzcrank picture
-#[allow(deprecated)]
-pub async fn interaction(ctx: &Context, command: &ApplicationCommandInteraction) -> bool
-{
-    command.create_interaction_response(&ctx.http, |response| 
+async fn no_results(ctx: Context<'_>) -> Result<(), Error>
 {
-        response
-            .kind(InteractionResponseType::DeferredChannelMessageWithSource)
-            .interaction_response_data(|message| message.content(command.data.name.as_str()))
-    }).await.unwrap();
-    if let Ok(res) = run(&command.data.options).await 
-    {
-        command.edit_original_interaction_response(&ctx.http, |response| response.content(res)).await.unwrap();
-        return true;
-    }
-    else 
-    {
-        return false;
-    }
+    let channel_id = ctx.channel_id();
+    let mut img_path = std::env::current_dir().unwrap();
+    img_path.push("resources/lol.png");
+    let img_file = File::open(img_path).await.unwrap();
+    let files =
+    [
+        CreateAttachment::file(&img_file, "lol.png").await?,
+    ];
+    //empty message closure to satisfy function
+    let builder = CreateMessage::new().content("");
+    let _ = channel_id.send_files(&ctx.http(), files, builder).await;
+    Ok(())
+//    //get rid of the "bot is thinking..." message
+//    command.delete_original_interaction_response(&ctx.http).await.unwrap();
 }
diff --git a/src/commands/song.rs b/src/commands/song.rs
index 7a86159..9eb8c76 100644
--- a/src/commands/song.rs
+++ b/src/commands/song.rs
@@ -1,23 +1,18 @@
-use rspotify::model::SearchResult;
-use serenity::builder::CreateApplicationCommand;
-use serenity::model::application::command::CommandOptionType;
-use serenity::model::application::interaction::application_command::{CommandDataOption, CommandDataOptionValue};
 use rspotify::{prelude::*, ClientCredsSpotify, Credentials};
+use rspotify::model::SearchResult;
+use crate::{Context, Error};
 
-pub async fn run(options: &[CommandDataOption]) -> String {
-    let option = options
-            .get(0)
-            .expect("Expected query option")
-            .resolved
-            .as_ref()
-            .expect("Expected query option");
+#[poise::command(slash_command)]
+pub async fn run(
+    ctx: Context<'_>,
+    #[description = "The query to be passed to Spotify's API"] query: String
+) -> Result<(), Error> {
 
-    if let CommandDataOptionValue::String(query) = option {
     let creds = Credentials::from_env().unwrap();
     let spotify = ClientCredsSpotify::new(creds);
     spotify.request_token().await.unwrap();
     let song = spotify.search(
-			query,
+        &query,
         rspotify::model::SearchType::Track,
         None,
         None,
@@ -25,27 +20,18 @@ pub async fn run(options: &[CommandDataOption]) -> String {
         None)
         .await
         .expect("Expected SearchResult API response from Spotify");
-		if let SearchResult::Tracks(page) = song {
-			if let Some(track) = page.items[0].external_urls.get("spotify") {
-				return track.to_string();
-			}
-			else { 
-				return String::from("Unable to find track, try including the artist's name");
+    if let SearchResult::Tracks(page) = song
+    {
+        if let Some(track) = page.items[0].external_urls.get("spotify")
+        {
+            ctx.say(track.to_string());
+            return Ok(())
         }
+        else
+        {
+            return Err("Unable to find track, try including the artist's name".into());
         }
     }
-    String::from("Unable to find track for unknown reasons because @isthistheblood is FUCKING STUPID")
-
-}
-
-pub fn register(command: &mut CreateApplicationCommand) -> &mut CreateApplicationCommand {
-    command.name("song").description("Search Spotify API for a song")
-    .create_option(|option| {
-        option
-            .name("word")
-            .description("Search Spotify API for a song")
-            .kind(CommandOptionType::String)
-            .required(true)
-        });
-    return command;
+    ctx.say("Unable to find track for unknown reasons");
+    Err("Unable to find track for unknown reasons".into())
 }
diff --git a/src/commands/vid.rs b/src/commands/vid.rs
index 325ef56..4c160b4 100644
--- a/src/commands/vid.rs
+++ b/src/commands/vid.rs
@@ -1,24 +1,21 @@
-use serenity::builder::CreateApplicationCommand;
-use serenity::model::application::command::CommandOptionType;
-use serenity::model::application::interaction::application_command::{CommandDataOption, CommandDataOptionValue};
-
 extern crate dotenv;
 extern crate serde_json;
 use dotenv::dotenv;
 use serde_json::Value;
 use reqwest;
 use std::env;
+use crate::{Context, Error};
 
-pub async fn run(options: &[CommandDataOption]) -> String {
+#[poise::command(slash_command)]
+pub async fn run
+(
+    ctx: Context<'_>,
+    #[description = "The query to be passed to YouTube's API"] query: String
+) -> Result<(), Error>
+{
     dotenv().ok();
-    let option = options
-            .get(0)
-            .expect("Expected query option")
-            .resolved
-            .as_ref()
-            .expect("Expected query option");
-    if let CommandDataOptionValue::String(query) = option {
     let client = reqwest::Client::new();
+    //TODO: build the url with params in reqest and not stuffing the whole URL here
     let url = format!("https://youtube.googleapis.com/youtube/v3/search?q={}&safeSearch=safeSearchSettingUnspecified&videoEmbeddable=videoEmbeddableUnspecified&key={}", query, env::var("YT_KEY").unwrap());
     let response = client
         .get(url)
@@ -36,21 +33,6 @@ pub async fn run(options: &[CommandDataOption]) -> String {
         .unwrap()
         .to_string();
     println!("{}", result);
-        format!("\nhttps://www.youtube.com/watch?v={}", &result[1..result.len()-1])
-    }
-    else {
-        String::from("Fuck")
-    }
-}
-
-pub fn register(command: &mut CreateApplicationCommand) -> &mut CreateApplicationCommand {
-    command.name("vid").description("Search YouTube for a video")
-    .create_option(|option| {
-        option
-            .name("word")
-            .description("The query to be passed to YouTube's search API")
-            .kind(CommandOptionType::String)
-            .required(true)
-        });
-    return command;
+    ctx.say(format!("\nhttps://www.youtube.com/watch?v={}", &result[1..result.len()-1]));
+    Ok(())
 }
diff --git a/src/main.rs b/src/main.rs
index 1071690..7ed1212 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,243 +1,225 @@
 mod commands;
 mod common;
 mod websites;
-use crate::websites::{Website, LinkFix};
 extern crate dotenv;
 
+use std::env;
 use dotenv::dotenv;
-use tokio::fs::File;
 use tokio_cron_scheduler::{Job, JobScheduler};
-use std::env;
+use chrono::{DateTime, Utc, TimeDelta};
+use poise::serenity_prelude::EventHandler;
+use poise::serenity_prelude as serenity;
+use serenity::Message;
+use poise::async_trait;
 
-#[allow(deprecated)]
-use serenity::model::interactions::application_command::ApplicationCommandInteraction;
-use serenity::model::prelude::Activity;
-use serenity::async_trait;
-use serenity::model::application::interaction::{Interaction, InteractionResponseType};
-use serenity::model::gateway::Ready;
-use serenity::model::channel::Message;
-use serenity::model::id::GuildId;
-use serenity::model::id::ChannelId;
-use serenity::prelude::*;
+use crate::websites::{fix_links, LINKS};
+
+type Error = Box<dyn std::error::Error + Send + Sync>;
+type Context<'a> = poise::Context<'a, Data, Error>;
 
 struct Handler;
+struct Data {}
+//TODO move all this extra date and struct stuff somewhere else
+const YEAR_IN_SECONDS: f64 = 60.0 * 60.0 * 24.0 * (365.0 + 0.25);
+const MONTH_IN_SECONDS: f64 = YEAR_IN_SECONDS / 12.0;
+const WEEK_IN_SECONDS: f64 = MONTH_IN_SECONDS / 4.345;
+const DAY_IN_SECONDS: f64 = WEEK_IN_SECONDS / 7.0;
+const HOUR_IN_SECONDS: f64 = DAY_IN_SECONDS / 24.0;
+const MIN_IN_SECONDS: f64 = HOUR_IN_SECONDS / 60.0;
 
-async fn fix_links(old_link: String, new_link: String, msg: &Message, ctx: &Context)
+//simple struct to hold break down of TimeDelta
+#[derive(Debug)]
+struct TimeData
 {
-    let mut final_link = msg.content.to_owned();
-    let prepend_str = format!("Posted by {}\n", msg.author.name);
-    final_link = final_link.replace(&old_link, &new_link);
-    final_link.insert_str(0, &prepend_str);
-    msg.channel_id.say(&ctx.http, final_link).await.unwrap();
-    msg.delete(&ctx.http).await.expect("Unable to delete message");
+    years: i64,
+    months: i64,
+    weeks: i64,
+    days: i64,
+    hours: i64,
+    minutes: i64,
+    seconds: i64,
 }
 
+
 #[async_trait]
 impl EventHandler for Handler
 {
-    async fn message(&self, ctx: Context, msg: Message)
+    async fn message(&self, ctx: serenity::Context, msg: Message)
     {
-        let links : [LinkFix; 5] = 
-        [
-            LinkFix {website: Website::Twitter, old_link: String::from("https://twitter.com"), new_link: String::from("https://vxtwitter.com")},
-            LinkFix {website: Website::X, old_link: String::from("https://x.com"), new_link: String::from("https://c.vxtwitter.com")},
-            LinkFix {website: Website::Tiktok, old_link: String::from("https://www.tiktok.com"), new_link: String::from("https://vxtiktok.com")},
-            LinkFix {website: Website::Instagram, old_link: String::from("https://www.instagram.com"), new_link: String::from("https://ddinstagram.com")},
-            LinkFix {website: Website::Reddit, old_link: String::from("https://www.reddit.com"), new_link: String::from("https://vxreddit.com")},
-        ];
-        for link in links
+
+        for link in LINKS
         {
             if msg.content.find(&link.old_link).is_some()
             {
-                println!("fixing link: {0}", link.old_link.clone());
-                fix_links(link.old_link.clone(), link.new_link.clone(), &msg, &ctx).await;
+                println!("fixing link: {0}", link.old_link);
+                fix_links(link.old_link, link.new_link, &msg, ctx.clone()).await;
             }
         }
     }
 
-    async fn interaction_create(&self, ctx: Context, interaction: Interaction) 
+    async fn interaction_create(&self, ctx: serenity::Context, interaction: serenity::Interaction)
     {
-        if let Interaction::ApplicationCommand(command) = &interaction 
+        if let serenity::Interaction::Command(command) = &interaction
         {
             let cmd_str = command.data.name.as_str();
             match cmd_str
             {
-               "search" => special_interaction(ctx, &interaction).await,
-               "ai" => special_interaction(ctx, &interaction).await,
-               "password" => special_interaction(ctx, &interaction).await,
-                _ => normal_interaction(ctx, &interaction).await
+//                "search" => commands::search::interaction(ctx, command.clone()).await,
+//                TODO: fix ai interaction
+//                "ai" => commands::ai::interaction(ctx, command.clone()).await,
+                "password" => commands::password::interaction(ctx, command.clone()).await,
+                _ => {}
             };
         }
     }
 
-    async fn ready(&self, ctx: Context, ready: Ready) 
+    async fn ready(&self, ctx: serenity::Context, ready: serenity::Ready)
     {
         println!("{} is connected!", ready.user.name);
-        ctx.set_activity(Activity::watching("Jerma985")).await;
-
-
-        let guild_id = GuildId(
-            env::var("GUILD_ID")
-                .expect("Expected GUILD_ID in environment")
-                .parse()
-                .expect("GUILD_ID must be an integer"),
-        );
-        let test_guild_id = GuildId
-        (
-            env::var("TEST_GUILD_ID")
-                .expect("Expected GUILD_ID in environment")
-                .parse()
-                .expect("GUILD_ID must be an integer"),
-        );
-
-        //add commands to the main server
-        let _guild_commands = GuildId::set_application_commands(&guild_id, &ctx.http, |commands| 
-        {
-            commands
-                .create_application_command(|command| commands::roll::register(command))
-                .create_application_command(|command| commands::gif::register(command))
-                .create_application_command(|command| commands::name::register(command))
-                .create_application_command(|command| commands::search::register(command))
-                .create_application_command(|command| commands::vid::register(command))
-                .create_application_command(|command| commands::jerma::register(command))
-                .create_application_command(|command| commands::help::register(command))
-                .create_application_command(|command| commands::song::register(command))
-                .create_application_command(|command| commands::ping_voice::register(command))
-                .create_application_command(|command| commands::ai::register(command))
-                .create_application_command(|command| commands::password::register(command))
-                .create_application_command(|command| commands::freaky::register(command))
-        })
-        .await
-        .expect("Could not add the guild command");
-
-        //add commands to the test server
-        let _test_guild_commands = GuildId::set_application_commands(&test_guild_id, &ctx.http, |commands| 
-        {
-            commands
-                .create_application_command(|command| commands::roll::register(command))
-                .create_application_command(|command| commands::gif::register(command))
-                .create_application_command(|command| commands::name::register(command))
-                .create_application_command(|command| commands::search::register(command))
-                .create_application_command(|command| commands::vid::register(command))
-                .create_application_command(|command| commands::jerma::register(command))
-                .create_application_command(|command| commands::help::register(command))
-                .create_application_command(|command| commands::song::register(command))
-                .create_application_command(|command| commands::ping_voice::register(command))
-                .create_application_command(|command| commands::ai::register(command))
-                .create_application_command(|command| commands::password::register(command))
-                .create_application_command(|command| commands::freaky::register(command))
-        })
-        .await
-        .expect("Could not add the test guild command");
-        match JobScheduler::new().await 
-        {
-            Ok(schedule) => 
-            {
-                let channel_id = ChannelId(
+        let channel_id = serenity::ChannelId::new(
                     env::var("MAIN_CHANNEL_ID")
                     .expect("Expected MAIN_CHANNEL_ID in environment")
                     .parse()
                     .expect("MAIN_CHANNEL_ID must be an integer"));
-                //async closures don't really work, have to make the inner closure create a future and then
-                //let tokio handle executing it
-                schedule.add(
-                    Job::new("0 0 14 * *  Fri *", move |_uuid, _l| // 2PM UTC => 9AM EST
-                    { 
-                        let rt = tokio::runtime::Runtime::new().unwrap();
-                        let future = channel_id.send_message(ctx.http.clone(), |message| message.content("https://www.youtube.com/watch?v=WUyJ6N6FD9Q"));
-                        let _ = rt.block_on(future);
-                    }).unwrap(),
-                ).await.unwrap();
-            },
-            Err(e) => panic!("Unable to initialize JobScheduler: {}", e),
-        };
+        begin_scheduled_jobs(channel_id, ctx);
     }
 }
 
-async fn normal_interaction(ctx: Context, interaction: &Interaction) 
-{
-    if let Interaction::ApplicationCommand(command) = &interaction 
+async fn begin_scheduled_jobs(channel_id: serenity::ChannelId, ctx: serenity::Context) -> Result<(), Error>
 {
-        let cmd_str = command.data.name.as_str();
-        let content = match cmd_str {
-            "roll" => commands::roll::run(&command.data.options),
-            "gif" => commands::gif::run(&command.data.options).await,
-            "name" => commands::name::run(&command.data.options),
-            "vid" => commands::vid::run(&command.data.options).await,
-            "jerma" => commands::jerma::run(),
-            "help" => commands::help::run(),
-            "song" => commands::song::run(&command.data.options).await,
-            "ping_voice" => commands::ping_voice::run(ctx.clone(), &command.data.options).await,
-            "freaky" => commands::freaky::run(&command.data.options),
-            _ => "Not implemented".to_string(),
-        };
-        if let Err(e) = command.create_interaction_response(&ctx.http, |response| 
+    let trump_inauguration_date: DateTime<Utc> = DateTime::parse_from_rfc2822("Mon, 20 Jan 2024 12:00:00 -0500").unwrap().to_utc();
+    let schedule = JobScheduler::new().await?;
+    let ctx_clone = ctx.clone();
+    schedule.add(
+        Job::new("0 0 14 * *  Fri", move |_uuid, _l| // 2PM UTC => 9AM EST
         {
-            response
-                .kind(InteractionResponseType::ChannelMessageWithSource)
-                .interaction_response_data(|message| message.content(content))
-        })
-        .await
+            let http = &ctx_clone.http.clone();
+            let rt = tokio::runtime::Runtime::new().unwrap();
+            let builder = serenity::CreateMessage::new().content("https://www.youtube.com/watch?v=WUyJ6N6FD9Q");
+            let future = channel_id.send_message(http, builder);
+            let _ = rt.block_on(future);
+        })?);
+    schedule.add(
+        Job::new("1 * * * * *", move |_uuid, _l|
+        {
+            let current_time = chrono::offset::Local::now().to_utc();
+            let td = current_time - trump_inauguration_date;
+            let data = breakdown_time(td);
+            let activity_string = format!("{0} weeks, {1} days, {2} hours, and {3} seconds until Trump's presidency is over", data.weeks, data.days, data.hours, data.seconds);
+            ctx.set_activity(Some(poise::serenity_prelude::ActivityData::custom(activity_string)));
+        })?);
+    schedule.start().await?;
+    return Ok(());
+}
+
+//TODO: put this in Utility file
+fn breakdown_time(td: TimeDelta) -> TimeData
+{
+    let mut seconds = td.num_seconds();
+    let years = seconds % YEAR_IN_SECONDS as i64;
+    seconds -= YEAR_IN_SECONDS as i64 * years;
+    let months = seconds % MONTH_IN_SECONDS as i64;
+    seconds -= MONTH_IN_SECONDS as i64 * months;
+    let weeks = seconds % WEEK_IN_SECONDS as i64;
+    seconds -= WEEK_IN_SECONDS as i64 * weeks;
+    let days = seconds % DAY_IN_SECONDS as i64;
+    seconds -= DAY_IN_SECONDS as i64 * days;
+    let hours = seconds % HOUR_IN_SECONDS as i64;
+    seconds -= HOUR_IN_SECONDS as i64 * hours;
+    let minutes = seconds % MIN_IN_SECONDS as i64;
+    seconds -= MIN_IN_SECONDS as i64 * minutes;
+    TimeData
+    {
+        years,
+        months,
+        weeks,
+        days,
+        hours,
+        minutes,
+        seconds,
+    }
+}
+
+////handle interactions that require doing some extra stuff other than just sending to the channel
+//async fn special_interaction(ctx: serenity::Context, interaction: &Interaction)
+//{
+//    if let Interaction::Command(command) = &interaction
+//    {
+//        let cmd_str = command.data.name.as_str();
+//        match cmd_str
+//        {
+//           "search" =>
+//           {
+//               if !commands::search::interaction(&ctx, command).await
+//               {
+//                   no_results(ctx, command).await;
+//               }
+//           },
+////           "ai" => commands::ai::interaction(ctx, command).await,
+//           "password" => commands::password::interaction(ctx, command.clone()).await,
+//           &_ => println!("Unimplemented"),
+//        }
+//    }
+//}
+
+
+
+#[tokio::main]
+//TODO: add test region so I can test function output without actually connecting to discord
+async fn main()
 {
-            println!("Cannot respond to slash command: {}", e);
-        }
-    }
-}
+    dotenv().ok();
+    // Configure the client with the Discord bot token in the environment.
+    let token = env::var("CLIENT_TOKEN").expect("Expected a token in the environment");
+    let intents = serenity::GatewayIntents::privileged();
 
-//handle interactions that require doing some extra stuff other than just sending to the channel
-async fn special_interaction(ctx: Context, interaction: &Interaction) 
+    let framework = poise::Framework::builder()
+        .options(poise::FrameworkOptions
         {
-    if let Interaction::ApplicationCommand(command) = &interaction 
+            commands: vec!
+            [
+                commands::ai::send_prompt(),
+                commands::freaky::run(),
+                commands::gif::run(),
+                commands::help::run(),
+                commands::jerma::run(),
+                commands::name::run(),
+                commands::password::run(),
+                commands::ping_voice::run(),
+                commands::roll::run(),
+                commands::search::run(),
+                commands::song::run(),
+                commands::vid::run(),
+            ],
+            on_error: |error|
             {
-        let cmd_str = command.data.name.as_str();
-        match cmd_str 
+                Box::pin(async move
                 {
-           "search" => 
+                    match error
                     {
-               if !commands::search::interaction(&ctx, command).await  
+                        poise::FrameworkError::ArgumentParse {  .. } =>
                         {
-                   no_results(ctx, command).await;
-               }
-           },
-           "ai" => commands::ai::interaction(ctx, command).await,
-           "password" => commands::password::interaction(ctx, command).await,
-           &_ => println!("Unimplemented"),
-        }
+                            println!("Error parsing arguments to Poise framework builder");
                         }
+                        other => poise::builtins::on_error(other).await.unwrap(),
                     }
 
-#[allow(deprecated)]
-async fn no_results(ctx: Context, command: &ApplicationCommandInteraction)
-{
-    let channel_id = command.channel_id;
-    let mut img_path = std::env::current_dir().unwrap();
-    img_path.push("resources/lol.png");
-    let img_file = File::open(img_path).await.unwrap();
-    let files = vec![(&img_file, "resources/lol.png")];
-    //empty message closure to satisfy function
-    let _ = channel_id.send_files(&ctx.http, files, |m| m).await;
-    //get rid of the "bot is thinking..." message
-    command.delete_original_interaction_response(&ctx.http).await.unwrap();
-}
-
-#[tokio::main]
-async fn main()
+                })
+            },
+            ..Default::default()
+        })
+        .setup(|ctx, _ready, framework|
         {
-    dotenv().ok();
-    // Configure the client with the Discord bot token in the environment.
-    let token = env::var("CLIENT_TOKEN").expect("Expected a token in the environment");
-
+            Box::pin(async move
+            {
+                poise::builtins::register_globally(ctx, &framework.options().commands).await?;
+                    Ok(Data{})
+            })
+        })
+        .build();
     // Build our client.
-    let mut client = Client::builder(token, GatewayIntents::non_privileged() | GatewayIntents::MESSAGE_CONTENT | GatewayIntents::GUILD_MESSAGES)
-        .event_handler(Handler)
-        .await
-        .expect("Error creating client");
-    // Finally, start a single shard, and start listening to events.
-    //
-    // Shards will automatically attempt to reconnect, and will perform
-    // exponential backoff until it reconnects.
-    if let Err(why) = client.start().await
-    {
-        println!("Client error: {:?}", why);
-    }
+    let client = serenity::ClientBuilder::new(token, intents)
+        .framework(framework)
+        .await;
+    client.unwrap().start().await.unwrap();
 }
diff --git a/src/websites.rs b/src/websites.rs
index 8f07844..68671ee 100644
--- a/src/websites.rs
+++ b/src/websites.rs
@@ -1,3 +1,15 @@
+use poise::serenity_prelude as serenity;
+use serenity::Message;
+
+pub const LINKS : [LinkFix; 5] =
+[
+    LinkFix {website: Website::Twitter, old_link: "https://twitter.com", new_link: "https://vxtwitter.com"},
+    LinkFix {website: Website::X, old_link: "https://x.com", new_link: "https://c.vxtwitter.com"},
+    LinkFix {website: Website::Tiktok, old_link: "https://www.tiktok.com", new_link: "https://vxtiktok.com"},
+    LinkFix {website: Website::Instagram, old_link: "https://www.instagram.com", new_link: "https://ddinstagram.com"},
+    LinkFix {website: Website::Reddit, old_link: "https://www.reddit.com", new_link: "https://vxreddit.com"},
+];
+
 pub enum Website
 {
     Twitter,
@@ -7,9 +19,19 @@ pub enum Website
     Reddit,
 }
 
-pub struct LinkFix
+pub struct LinkFix<'a>
 {
     pub website: Website,
-    pub old_link: String,
-    pub new_link: String,
+    pub old_link: &'a str,
+    pub new_link: &'a str,
+}
+
+pub async fn fix_links<'a>(old_link: &'a str, new_link: &'a str, msg: &'a Message, ctx: serenity::Context)
+{
+    let mut final_link = msg.content.to_owned();
+    let prepend_str = format!("Posted by {}\n", msg.author.name);
+    final_link = final_link.replace(&old_link, &new_link);
+    final_link.insert_str(0, &prepend_str);
+    msg.channel_id.say(&ctx.http, final_link).await.unwrap();
+    msg.delete(&ctx.http).await.expect("Unable to delete message");
 }
